# NCM (Network Configuration Management) 系统开发规划书

## 1. 总体架构设计

### 1.1 核心架构：异步任务队列

面对 1000+ 台设备的管理需求，采用**前后端分离 + 异步任务队列**架构。

- **Web 层 (FastAPI + Vue 3)**
  - 负责接收用户指令、参数校验、权限控制
  - 下发任务到消息队列并立即返回任务 ID
  - 提供任务状态查询与结果展示接口

- **Worker 层 (Celery)**
  - 独立进程执行耗时任务（SSH 连接、Nmap 扫描、配置对比）
  - 支持任务优先级、失败重试、结果持久化
  - 使用 Redis 作为消息代理和结果存储后端

- **监控层 (Flower)**
  - 实时监控任务队列状态
  - 查看 Worker 负载、失败任务统计
  - 支持手动重启失败任务

## 1.3 核心技术栈详解

### 为什么需要 Nornir？

**Nornir 的核心价值**

- **专为网络自动化设计**：不是通用任务队列，而是针对网络设备批量操作优化
- **内置并发管理**：自动处理线程池，无需手动管理异步逻辑
- **失败容错**：单台设备失败不影响其他设备继续执行
- **结果聚合**：自动收集所有设备执行结果，统一返回
- **插件化架构**：支持 Scrapli、Netmiko、NAPALM 等多种连接库

**Nornir 与 Celery 的配合**

- Celery 负责任务调度（定时备份、触发扫描）
- Nornir 负责批量执行（连接 100 台设备并发执行备份）
- 流程：Celery 任务 → 调用 Nornir → Nornir 并发执行 → 返回聚合结果

### 为什么需要 TextFSM + ntc-templates？

**解决的核心痛点**

- 网络设备输出是非结构化文本（show 命令返回人类可读格式）
- 需要解析为结构化数据才能入库、对比、分析
- 手动正则表达式解析维护成本高、容易出错

**ntc-templates 的优势**

- 社区维护的 700+ 个现成模板（覆盖主流厂商和命令）
- 支持 Cisco、Huawei、Juniper、Arista、HP、H3C 等
- 开箱即用，无需自己编写正则表达式

**典型应用场景**

- 解析 ARP 表：`show ip arp` → [{ip: "192.168.1.1", mac: "aa:bb:cc:dd:ee:ff", interface: "Vlan10"}]
- 解析 MAC 表：`show mac address-table` → [{vlan: 10, mac: "aa:bb:cc", port: "Gi1/0/1"}]
- 解析 LLDP：`show lldp neighbors detail` → [{local_port: "Gi1/0/24", neighbor: "switch2"}]
- 解析接口状态：`show interfaces status` → [{port: "Gi1/0/1", status: "connected", vlan: 10}]

### 为什么需要 Jinja2？

**安全性考虑**

- 禁止用户直接输入命令（防止误操作或恶意注入）
- 模板预定义了安全的配置结构
- 用户只能输入受限的业务参数

**标准化与规范化**

- 确保所有配置符合企业标准（如命名规范、VLAN 范围）
- 避免人为配置差异导致的故障
- 便于配置审计和合规检查

**多厂商兼容**

- 同一个业务需求（创建 VLAN），不同厂商命令不同
- Jinja2 模板可根据设备类型自动选择正确语法
- 用户无需关心厂商差异

| 模块 | 技术选型 | 理由 |
|## 1.4 设备品牌分布与适配策略

### 实际环境统计

- **H3C**：85%（主力品牌，优先适配）
- **华为**：10%（次要品牌）
- **思科**：4%（少量设备）
- **其他**：1%（Dell、锐捷等小众品牌）

### 厂商适配优先级

1. **第一优先级（H3C）**
   - 重点测试 H3C Comware V5/V7 命令兼容性
   - 优先开发 H3C 专用 TextFSM 模板（如需）
   - Jinja2 配置模板以 H3C 语法为基础

2. **第二优先级（华为）**
   - 使用 ntc-templates 的 huawei 系列模板
   - 测试 VRP 系统命令差异（如 display vs show）

3. **第三优先级（思科）**
   - ntc-templates 对思科支持最完善，直接使用
   - 作为功能验证的参考标准

4. **兜底方案（其他品牌）**
   - 提供通用模板 + 自定义扩展能力
   - 支持原始文本存储，降级为手动分析

### 厂商差异处理策略

- **命令映射表**：维护统一命令到厂商特定命令的映射（如 `show version` → `display version`）
- **自动检测**：通过 SSH Banner 或 `show version` 输出自动识别设备品牌
- **模板继承**：Jinja2 模板使用 `{% if vendor == 'h3c' %}` 条件分支
- **解析兜底**：TextFSM 解析失败时保存原始输出，支持人工分析

---

## 1.5 OTP 动态认证架构设计

### 认证方式统计

- **OTP 动态验证码**：98% 设备（不同部门 + 设备分组的验证码不同）
- **静态密码**：2% 设备（数据库加密存储）

### 核心挑战

1. **OTP 不可存储**：每次连接都需要新的动态验证码
2. **部门差异**：不同部门（区域/机房）使用不同 OTP 种子
3. **设备分组差异**：同一部门下，核心/汇聚/接入层使用不同 OTP 账号
4. **批量操作困难**：1000 台设备不可能每台手动输入 OTP
5. **会话时效性**：SSH 会话超时后需重新认证

### OTP 凭据层级结构

```
Department（部门表，顶级部门 = 区域）
└── DeviceGroupCredential（设备分组凭据表）
    ├── 核心层凭据（dept_id + device_group='core' + username + otp_seed）
    ├── 汇聚层凭据（dept_id + device_group='distribution' + username + otp_seed）
    └── 接入层凭据（dept_id + device_group='access' + username + otp_seed）
```

**说明**：

- **区域 = 顶级部门**（如"华北机房A"），复用现有 Department 表，无需单独创建 Region 表
- 每个"部门 + 设备分组"组合对应一个独立的 **账号 + OTP 种子**
- 同一时间下，同区域的核心、汇聚、接入层 OTP 动态验证码各不相同
- 设备通过 `dept_id` + `device_group` 确定使用哪个凭据（账号 + OTP）
- DeviceGroupCredential 表以 `(dept_id, device_group)` 作为复合唯一键

### 解决方案：OTP 会话复用 + 智能缓存

#### 方案一：OTP 短期缓存 + 并发登录（推荐）

**设计原理**

- RADIUS OTP 有效期很短（约 30 秒），无法长期保持会话
- 用户输入 OTP 后，系统缓存该 OTP **1 分钟**
- 1 分钟内所有同分组设备的**新建登录**复用这个 OTP
- OTP 过期或认证失败时，提示用户重新输入，旧 OTP 立即失效
- 新 OTP 继续缓存 1 分钟，服务后续设备登录

**核心策略**

- **短缓存**：OTP 缓存仅 1 分钟（而非 30 分钟），贴合 RADIUS 实际有效期
- **快登录**：收到 OTP 后立即并发登录所有目标设备（抢在 30 秒内完成）
- **失败重试**：OTP 过期导致认证失败时，自动暂停任务并请求新 OTP
- **无缝续期**：新 OTP 输入后，从失败设备继续执行，无需重新开始

**实现流程**

1. 用户发起批量任务，系统分析目标设备涉及哪些 **部门 + 设备分组** 组合
2. 前端弹窗显示所需凭据列表，用户为每个组合输入当前 OTP 动态验证码
3. 系统从 DeviceGroupCredential 表获取对应账号，OTP 缓存到 Redis（TTL=60秒）
4. **立即并发登录**：Nornir 使用缓存的 OTP 并发连接所有同分组设备
5. 1 分钟内如有新设备需要登录，从 Redis 获取缓存的 OTP 复用
6. 若认证失败（OTP 过期）：
   - 暂停当前批次任务
   - 前端弹窗提示"OTP 已过期，请输入新的 OTP"
   - 用户输入新 OTP 后，旧缓存失效，新 OTP 缓存 1 分钟
   - 从失败设备继续执行任务
7. OTP 缓存状态存 Redis：`otp_cache:{dept_id}:{device_group}` → `{otp_value, expire_at}`

**优势**

- 贴合 RADIUS 30 秒有效期，避免无效缓存
- 1 分钟内同分组批量登录复用同一个 OTP，减少用户输入次数
- OTP 过期时智能提示，支持断点续传
- 不同设备分组的 OTP 缓存相互隔离，互不影响

**时序示意**

```
用户输入 OTP (T=0s)
    ↓
Redis 缓存 OTP (TTL=60s)
    ↓
Nornir 并发登录 100 台设备 (T=0~25s，在 OTP 有效期内完成)
    ↓
[场景A] 全部成功 → 任务完成
    ↓
[场景B] 第 80 台设备登录时 OTP 过期 (T=35s)
    ↓
暂停任务，弹窗请求新 OTP
    ↓
用户输入新 OTP (T=45s)
    ↓
Redis 更新缓存，从第 80 台继续执行
```

#### 方案二：OTP 令牌缓存（备选）

**适用场景**：如果设备支持 TOTP（Time-based OTP，如 Google Authenticator）

**设计原理**

- 管理员首次配置时输入 OTP 种子（Secret Key）和对应账号
- 种子加密存储到 DeviceGroupCredential 表（按"部门 + 设备分组"管理）
- 使用 PyOTP 库实时生成当前有效的 OTP 验证码
- 无需用户手动输入，系统自动计算

**实现流程**

1. 系统管理员在"凭据管理"页面配置各部门各设备分组的凭据（账号 + OTP 种子）
2. 种子使用 AES-256 加密存储（与设备密码同级别安全）
3. 任务执行时，后端根据设备的 `dept_id` + `device_group` 查询 DeviceGroupCredential 表获取对应凭据
4. 使用凭据中的账号 + PyOTP 生成当前时间窗口的 6 位验证码
5. 自动完成 SSH 认证，无需人工介入

**局限性**

- 仅支持标准 TOTP 协议（RFC 6238）
- 如果设备使用私有 OTP 算法则不适用
- 需要管理员有权限获取 OTP 种子

#### 方案三：交互式认证（保底方案）

**适用场景**：少量关键设备的临时操作

**设计原理**

- 用户在前端勾选设备后，系统提示"需要手动认证"
- 弹出 Web 终端（WebSocket + xterm.js），模拟真实 SSH 交互
- 用户看到 OTP 提示后手动输入验证码
- 认证成功后后端接管会话，自动执行任务

**实现流程**

1. 前端显示"正在连接设备 192.168.1.1，请输入 OTP"
2. 用户在 Web 终端中输入验证码
3. 后端捕获认证成功信号，切换到自动化模式
4. 执行预定任务（如备份配置）
5. 任务完成后关闭会话

**局限性**

- 无法真正实现批量自动化（每台设备都需人工输入）
- 仅适合少量设备的应急操作

### 推荐架构：方案一（OTP 缓存）+ 方案二（种子存储）混合

**最佳实践**

- **核心设备（20%）**：使用方案一（OTP 短期缓存），任务执行前弹窗要求输入 OTP
- **普通设备（78%）**：使用方案二（种子存储），完全自动化
- **特殊设备（2%）**：静态密码，直接从 Device 表读取

**数据库设计扩展**

- **Device 表**增加字段：
  - `auth_type`：ENUM('static', 'otp_seed', 'otp_manual')
  - `dept_id`：关联部门表（顶级部门 = 区域）
  - `device_group`：设备分组 ENUM('core', 'distribution', 'access')
  - 凭据获取：OTP 类型通过 `dept_id` + `device_group` 查询 DeviceGroupCredential 表

- **DeviceGroupCredential 表**（新增，部门设备分组凭据）：
  - `dept_id`：关联部门 ID（外键，指向顶级部门/区域）
  - `device_group`：设备分组 ENUM('core', 'distribution', 'access')
  - `username`：SSH 账号（**每个分组独立账号**）
  - `otp_seed_encrypted`：该分组的 OTP 种子（AES-256 加密存储）
  - `auth_type`：认证类型 ENUM('otp_seed', 'otp_manual')
  - 复合唯一键：`(dept_id, device_group)`

**凭据查询逻辑**

```python
# 示例：获取设备凭据
def get_device_credential(device: Device) -> Credential:
    if device.auth_type == 'static':
        # 静态密码设备，直接返回设备表中的账号密码
        return Credential(username=device.username, password=decrypt(device.password_encrypted))
    else:
        # OTP 设备，从 DeviceGroupCredential 表获取
        cred = DeviceGroupCredential.query.filter_by(
            dept_id=device.dept_id,
            device_group=device.device_group
        ).first()
        otp_code = pyotp.TOTP(decrypt(cred.otp_seed_encrypted)).now()
        return Credential(username=cred.username, password=otp_code)
```

### OTP 安全加固措施

- OTP 种子使用独立的加密密钥（与设备密码密钥不同）
- 加密密钥分片存储（一半在配置文件，一半在环境变量）
- OTP 种子访问记录到审计日志（谁在何时获取了哪个部门哪个设备分组的种子）
- DeviceGroupCredential 表的增删改操作强制记录审计日志
- OTP 缓存存 Redis（TTL=60秒，自动过期，重启失效）
- 前端输入的临时 OTP 不记录日志（仅在 Redis 中保留 1 分钟）
- 凭据管理页面需要额外权限验证（仅高级管理员可操作）

| 模块类别   | 技术选型                               | 选型说明                                                                                   |
| ---------- | -------------------------------------- | ------------------------------------------------------------------------------------------ |
| SSH 库     | Scrapli（主） + Netmiko（兼容）        | Scrapli 原生支持异步，适合高并发场景；Netmiko 作为兼容方案，用于处理部分特殊厂商或遗留设备 |
| 并发框架   | Nornir 3.x                             | 面向网络自动化设计，内置并发执行、失败重试与结果聚合能力，显著简化大规模设备管理           |
| 数据解析   | TextFSM + ntc-templates                | 将非结构化的设备命令输出（如 show 命令）解析为结构化数据，覆盖主流网络厂商                 |
| 配置模板   | Jinja2                                 | 通过模板生成标准化配置块，用户仅需输入变量（如 VLAN ID、IP 地址），避免手工拼写命令        |
| 任务队列   | Celery + Redis                         | 成熟稳定，支持任务重试与故障恢复，社区活跃，适合异步与长耗时任务                           |
| 网络扫描   | Nmap（详细扫描） + Masscan（快速探测） | Masscan 用于大网段快速存活探测，Nmap 提供端口、服务与操作系统识别等深度扫描能力            |
| 配置存储   | PostgreSQL JSONB + MinIO               | 小型配置存储于 JSONB 字段，支持索引与查询；大型配置压缩后存入对象存储                      |
| 拓扑可视化 | vis.js / ECharts                       | 支持交互式网络拓扑展示，可点击节点查看设备与链路详情                                       |

---

## 2. 核心功能模块详细设计

### 🛠️ 模块一：配置备份 (Configuration Backup)

#### 2.1.1 设计目标

- 支持多厂商设备（Cisco、华为、H3C、Juniper 等）
- 定时自动备份 + 手动触发备份
- 配置版本化管理，支持历史版本回溯

#### 2.1.2 实现策略

**凭据安全管理**

- **静态密码设备（2%）**：使用 AES-256 对称加密存储到数据库专用字段
- **OTP 设备（98%）**：
  - **OTP 种子存储方案**：种子加密后存数据库（按部门+设备分组），运行时使用 PyOTP 实时生成验证码
  - **OTP 缓存方案**：用户输入 OTP 后缓存 1 分钟，并发登录复用，过期后断点续传
  - **混合方案（推荐）**：普通设备用种子自动生成，核心设备用 OTP 缓存手动输入
- 加密密钥存储在服务器配置文件（权限 600）或环境变量
- OTP 种子使用独立加密密钥（与设备密码密钥分离）
- 建立独立的凭据审计日志（记录密码修改、OTP 种子访问、操作人）
- 支持设备分组使用不同凭据（按区域、设备类型）
- 为 NCM 系统创建专用只读账号（权限最小化原则）

**厂商兼容层**

- 针对 H3C（85% 设备）优先适配，重点测试 Comware V5/V7 命令
- 华为（10%）使用 ntc-templates 的 huawei 系列模板，处理 `display` vs `show` 差异
- 思科（4%）直接使用成熟的 ntc-templates
- 建立统一命令映射表（抽象命令 → 厂商特定命令）
- 通过 SSH Banner 或 `show version` 自动检测设备品牌型号
- 针对不同厂商封装统一的命令适配器
- 支持自定义厂商命令模板（应对 1% 小众设备）
- TextFSM 解析失败时降级保存原始文本供人工分析

**并发控制**

- 使用 **Nornir** 框架统一管理设备连接和任务执行
- Nornir 内置失败重试、结果聚合、任务分组功能
- 配置 Nornir 使用 Scrapli 作为连接插件（ScrapliRunner）
- 设置全局并发数上限（num_workers=50-100），避免网络拥塞
- **OTP 缓存管理**：
  - 按"部门 + 设备分组"缓存 OTP（Redis TTL=60秒）
  - 用户输入 OTP 后立即并发登录所有目标设备（抢在 30 秒有效期内）
  - 1 分钟内同分组新设备登录复用缓存的 OTP
  - OTP 过期导致认证失败时，暂停任务并请求新 OTP
  - 新 OTP 输入后从失败设备继续执行（断点续传）
  - 同一部门下，核心、汇聚、接入层的 OTP 缓存相互隔离
- 失败设备自动加入重试队列（最多重试 3 次，间隔递增）
- 支持按设备组（核心/汇聚/接入）、区域分批执行任务

**存储策略**

- **小配置（<50KB）**：直接存 PostgreSQL TEXT 字段
- **大配置（>50KB）**：压缩后存 MinIO，数据库仅存元数据和访问路径
- 每次备份记录时间戳、操作人、备份方式（定时/手动）
- 保留策略：最近 30 天每天一份，30-90 天每周一份，90 天以上每月一份

**异常处理**

- 建立完善的任务状态表（Pending/Running/Success/Failed）
- 失败原因分类（连接超时、认证失败、权限不足、设备不可达）
- 支持批量重试失败设备
- 关键设备备份失败立即告警

---

### ⚖️ 模块二：智能差异对比与告警 (Intelligent Diff & Alert)

#### 2.2.1 设计目标

- 自动检测配置变更并生成可视化差异报告
- 识别高危变更并自动升级告警等级
- 过滤无关变更（时间戳、注释等）

#### 2.2.2 实现策略

**差异检测机制**

- 每次备份完成后自动对比上一次配置的 MD5 哈希值
- 哈希不一致时触发详细差异分析（使用 difflib）
- 生成 HTML 格式的差异报告（支持高亮显示）

**智能告警规则**

- **高危变更（Critical）**
  - 核心 VLAN 配置修改
  - 关键端口 shutdown/no shutdown 状态变更
  - ACL 规则删除
  - 路由协议配置变更
  - STP 根桥优先级调整

- **中危变更（Warning）**
  - 端口描述修改
  - VLAN 成员变更
  - QoS 策略调整

- **低危变更（Info）**
  - 时间戳更新
  - 日志缓冲区大小调整
  - SNMP community 修改

**过滤无关变更**

- 自动忽略纯时间戳变更
- 过滤设备自动生成的注释
- 支持自定义忽略规则（正则表达式）

**告警渠道**

- 系统内消息通知
- 邮件告警（支持分级发送不同收件人）
- Webhook 对接企业微信/钉钉/飞书
- 告警聚合（5 分钟内同一设备多次变更合并为一条）

**前端展示**

- 集成 Monaco Editor Diff Mode 实现代码级对比
- 支持左右分栏显示新旧配置
- 高亮显示新增、删除、修改的行
- 提供差异下载功能（PDF/HTML）

---

### ⚡ 模块三：安全批量下发 (Secure Batch Deployment)

#### 2.3.1 设计目标

- 支持批量修改 VLAN、端口描述、ACL 策略
- 多重安全机制防止误操作
- 完整的操作审计与回滚能力

#### 2.3.2 安全机制设计

**模板化配置管理**

- 禁止直接输入命令，仅允许使用预定义 Jinja2 模板
- 用户仅输入业务参数（如 vlan_id: 10, vlan_name: "Sales", ip_address: "192.168.1.1"）
- 后端通过 Jinja2 渲染生成标准配置块
- 内置常用模板库：
  - VLAN 创建与删除
  - 接口配置（IP、描述、速率、双工）
  - ACL 策略更新
  - 路由协议配置（OSPF、BGP）
  - QoS 策略配置
- 支持多厂商模板（Cisco、Huawei、H3C 等）
- 模板继承机制：基础模板 + 厂商差异化扩展
- 模板版本控制：每次修改记录变更历史
- 自定义模板需管理员审批后才能启用

**Jinja2 模板设计原则**

- 参数校验：使用正则表达式验证输入合法性（VLAN 范围 1-4094）
- **厂商条件渲染**：根据设备品牌自动选择命令语法
  - H3C（85%）：`system-view` / `quit`
  - 华为（10%）：`system-view` / `display` 命令
  - 思科（4%）：`configure terminal` / `show` 命令
- 循环生成：批量创建多个 VLAN 或接口配置
- 变量默认值：关键参数提供安全默认值（如 shutdown 状态）
- 注释生成：自动添加配置时间戳和操作人信息
- 模板示例：H3C 创建 VLAN 模板会根据设备类型自动适配华为或思科语法

**命令白名单机制**

- 建立允许执行的命令正则表达式库
- 拦截高危命令（reload、write erase、format 等）
- 限制单次下发的命令行数（建议不超过 50 行）

**三级审批流程**

- **提交阶段**：操作人填写变更说明、影响范围、回退方案
- **审批阶段**：根据设备重要性配置不同审批人（核心设备需双人审批）
- **执行阶段**：审批通过后进入灰度发布流程

**灰度发布机制**

- **第一阶段**：选取 1 台测试设备执行并验证
- **验证方式**：
  - 检查命令执行返回是否包含错误信息
  - 执行后立即抓取配置对比预期结果
  - 测试设备连通性（Ping 测试）
- **第二阶段**：测试通过后分批执行
  - 每批 5-10 台设备，间隔 30 秒
  - 每批执行后暂停等待人工确认
  - 支持中途暂停或中止

**Dry-Run 试运行**

- 执行前生成完整的命令预览
- 使用语法检查工具验证命令合法性
- 模拟执行并预测配置变更结果
- 人工复核通过后才允许真实执行

**回滚能力**

- 执行前自动备份当前配置
- 支持一键回滚到变更前状态
- 记录回滚操作并重新触发审批流程

**操作审计**

- 记录所有 SSH 会话日志（独立表存储）
- 记录执行的每一条命令及返回结果
- 保存变更前后配置快照
- 生成变更报告（PDF 格式可导出）

---

### 🔍 模块四：智能设备发现 (Intelligent Discovery)

#### 2.4.1 设计目标

- 自动发现网段内存活设备
- 识别设备厂商、型号、操作系统
- 与 CMDB 数据进行比对发现影子资产

#### 2.4.2 实现策略

**扫描策略分层**

- **快速存活探测（每小时）**
  - 使用 Masscan 快速扫描开放端口
  - 仅探测 22/23/80/443 等关键端口
  - 更新设备在线状态

- **详细信息扫描（每天）**
  - 使用 Nmap 进行 OS 指纹识别
  - 获取设备开放服务列表
  - 通过 OUI 数据库识别 MAC 地址厂商

**异步执行机制**

- 扫描任务通过 Celery Worker 异步执行
- 支持按网段分片扫描（避免单次任务过大）
- 扫描进度实时推送到前端（WebSocket）

**数据存储与比对**

- 扫描结果存入 Discovery 表（包含 IP、MAC、厂商、首次发现时间）
- 与 CMDB 已录入设备进行自动匹配
- 标记未在 CMDB 中的设备为"待确认资产"
- 识别 CMDB 中已下线但仍存活的设备

**智能识别规则**

- 根据开放端口推测设备类型（22/23 → 网络设备，3389 → Windows，3306 → 数据库）
- 结合 Banner 信息识别厂商（Cisco IOS、Huawei VRP 等）
- 支持自定义识别规则库

---

### 🔗 模块五：拓扑可视化与精准定位 (Topology & Locator)

#### 2.5.1 设计目标

- 自动绘制网络拓扑图
- 快速定位 PC 连接的交换机及端口
- 支持多种查询方式（IP/MAC/主机名）

#### 2.5.2 拓扑绘制策略

**数据采集与解析**

- **LLDP/CDP 数据采集**
  - 定时抓取所有交换机的 LLDP 邻居信息（show lldp neighbors detail）
  - 使用 **TextFSM + ntc-templates** 解析命令输出为结构化数据
  - 建立交换机互联关系拓扑图
  - 识别核心层、汇聚层、接入层

- **ARP 表采集与解析**
  - 从核心交换机或三层设备抓取完整 ARP 表（show ip arp）
  - 使用 TextFSM 模板解析输出（IP、MAC、Interface、Age）
  - 建立 IP 到 MAC 的映射关系
  - 支持增量更新（仅同步变更部分）

- **MAC 地址表采集与解析**
  - 从所有接入交换机抓取 MAC 地址表（show mac address-table）
  - 使用 ntc-templates 统一解析不同厂商输出格式
  - 建立 MAC 到交换机端口的映射关系
  - 标记端口类型（Trunk/Access）

**TextFSM 解析流程**

- 执行命令后获取原始文本输出
- 根据设备类型（Cisco IOS、Huawei、H3C）选择对应 TextFSM 模板
- 解析为字典列表格式，直接存入数据库
- 对于 ntc-templates 未覆盖的厂商，支持自定义模板扩展

**数据缓存优化**

- ARP 表和 MAC 地址表设置 10 分钟缓存
- 避免每次查询都 SSH 登录设备
- 支持手动刷新缓存

**前端可视化**

- 使用 vis.js 或 ECharts 绘制交互式拓扑图
- 节点大小根据连接端口数动态调整
- 点击节点显示设备详细信息（IP、型号、端口状态）
- 点击链路显示带宽利用率（需 SNMP 支持）
- 支持拓扑图导出（PNG/SVG）

#### 2.5.3 精准定位功能

**多维度查询**

- **IP 查询**：IP → ARP 表获取 MAC → MAC 表获取端口
- **MAC 查询**：直接查 MAC 表获取所在端口
- **主机名查询**：通过 DNS 反查 IP 后按 IP 查询流程
- 支持模糊匹配（输入部分 MAC 地址或 IP 网段）

**查询结果展示**

- 显示完整路径：PC IP → MAC 地址 → 交换机 IP → 端口号
- 标注端口状态（Up/Down）、VLAN、端口描述
- 显示端口最后活跃时间
- 支持一键跳转到交换机管理页面

**历史轨迹追踪**

- 记录 MAC 地址的历史位置变更
- 识别频繁移动的设备（可能为非法接入）
- 生成设备移动路径图

---

### 📝 模块六：生命周期管理 (Lifecycle Management)

#### 2.6.1 设计目标

- 记录设备从入库到报废的全生命周期
- 与自动扫描数据联动验证设备状态
- 支持资产盘点与异常检测

#### 2.6.2 核心功能

**资产状态流转**

- 入库 → 在库 → 领用 → 在用 → 维修 → 报废
- 每次状态变更记录操作人、时间、原因
- 支持批量导入资产信息（Excel）

**联动自动扫描**

- 已报废设备若被 Nmap 扫描发现仍存活，自动标记"异常"
- 在用设备若连续 7 天扫描不到，自动告警"疑似离线"
- 在库设备若被扫描到在线，自动告警"疑似私自启用"

**资产盘点**

- 支持按部门、位置、设备类型生成盘点清单
- 扫描结果与盘点清单自动比对
- 标注盘盈（扫描到但未在 CMDB）、盘亏（CMDB 有但扫描无）设备

**统计分析**

- 设备数量趋势图（按品牌、型号、部门）
- 设备使用年限分布
- 即将过保设备提醒
- 报废设备回收统计

---

## 3. 开发路线图 (Roadmap)

### 📅 Phase 0：基础设施搭建（1-2 周）

**目标**：建立异步任务框架，为后续开发奠定基础

- [ ] 部署 Celery + Redis 环境
- [ ] 配置 Flower 监控面板
- [ ] 搭建 **Nornir** 框架（配置 Inventory、设备分组）
- [ ] 集成 **TextFSM + ntc-templates**（验证 H3C/华为/思科常用命令解析）
- [ ] 建立 **Jinja2 模板库**基础结构（模板存储表、版本管理、厂商适配）
- [ ] 建立数据库表结构（Device、DeviceGroupCredential、Backup、Task、Discovery、Template 等）
- [ ] 实现凭据加密存储与解密模块（双密钥体系）
- [ ] **开发 OTP 认证模块**：
  - [ ] PyOTP 集成（种子存储 + 验证码生成）
  - [ ] Redis OTP 缓存管理（缓存 1 分钟、过期清理、断点续传）
  - [ ] 前端 OTP 输入弹窗（支持过期后重新输入）
- [ ] 搭建 Scrapli 和 Netmiko 基础连接测试（优先测试 H3C）

---

### 📅 Phase 1：读能力 + 快速见效功能（3-4 周）

**目标**：实现核心备份功能 + 精准定位（运维痛点）

- [ ] 实现 Scrapli H3C 设备连接适配（Comware V5/V7）
- [ ] 开发厂商自动检测模块（SSH Banner 识别 + display/show version 解析）
- [ ] 建立统一命令映射表（show → display 等）
- [ ] 使用 **Nornir** 封装批量备份任务（支持并发、失败重试、OTP 缓存复用）
- [ ] 开发配置备份任务（定时 + 手动，含 OTP 认证流程）
- [ ] 实现配置版本管理与历史查看
- [ ] 使用 **TextFSM** 解析 ARP 表和 MAC 地址表（H3C 优先适配）
- [ ] 开发 ARP 表和 MAC 地址表采集模块（基于 Nornir 批量执行）
- [ ] 实现 IP/MAC 精准定位功能（前端查询页面）
- [ ] 完成备份任务失败重试机制（含 OTP 过期断点续传）

**里程碑**：运维人员可通过系统快速定位 PC 位置，减少现场排查时间；OTP 缓存机制支持批量登录和断点续传

---

### 📅 Phase 2：自动化发现与拓扑可视化（4-5 周）

**目标**：建立资产自动发现能力，绘制网络拓扑

- [ ] 集成 Nmap 和 Masscan 扫描引擎
- [ ] 开发扫描任务调度（按网段分片异步执行）
- [ ] 实现 OUI 数据库厂商识别
- [ ] 开发扫描结果与 CMDB 比对逻辑
- [ ] 使用 **TextFSM** 采集并解析 LLDP 邻居信息（H3C/华为/思科多厂商适配）
- [ ] 开发 TextFSM 解析失败降级处理（保存原始文本）
- [ ] 使用 **Nornir** 批量采集拓扑数据（LLDP、ARP、MAC 表）
- [ ] 使用 vis.js 绘制交互式拓扑图
- [ ] 实现拓扑图节点点击查看详情（显示厂商信息）

**里程碑**：自动发现影子资产，可视化展示网络拓扑结构；H3C 设备拓扑采集成功率达 95%+

---

### 📅 Phase 3：智能对比与告警（3-4 周）

**目标**：实现配置变更自动检测与分级告警

- [ ] 开发配置差异对比引擎（difflib）
- [ ] 实现智能告警规则引擎（高/中/低危分级）
- [ ] 配置无关变更过滤规则
- [ ] 集成 Monaco Editor Diff Mode
- [ ] 开发告警渠道（邮件 + Webhook）
- [ ] 实现告警聚合与去重

**里程碑**：配置变更自动检测并推送告警，减少人工巡检

---

### 📅 Phase 4：安全批量下发（5-6 周）

**目标**：实现自动化配置下发，但确保安全可控

- [ ] 设计 **Jinja2 模板库**（H3C/华为/思科三套常用配置模板）
- [ ] 开发模板管理界面（创建、编辑、版本控制、厂商多选）
- [ ] 实现模板参数校验与多厂商预览功能
- [ ] 开发命令白名单校验模块（按厂商分类）
- [ ] 实现三级审批流程（集成 RBAC）
- [ ] 开发 Dry-Run 试运行功能（基于 Jinja2 渲染预览，按厂商分组展示）
- [ ] 使用 **Nornir** 实现灰度发布机制（测试 → 分批执行，含 OTP 缓存与断点续传）
- [ ] 开发自动回滚功能
- [ ] 完善操作审计日志（含 OTP 使用记录）

**里程碑**：运维人员可安全批量修改设备配置，减少重复劳动；支持 H3C/华为/思科三种厂商自动适配

---

### 📅 Phase 5：生命周期与优化（3-4 周）

**目标**：完善资产管理，优化系统性能

- [ ] 实现设备生命周期状态流转
- [ ] 开发联动扫描结果验证资产状态
- [ ] 实现资产盘点功能
- [ ] 开发统计分析报表
- [ ] 优化大配置文件存储（MinIO）
- [ ] 实现配置保留策略自动清理
- [ ] 性能测试与优化（1000+ 设备并发）

**里程碑**：系统功能完整，性能满足生产环境要求

---

## 4. 数据库设计要点

### 4.1 核心表结构

**Device（设备表）**

- 基础信息：IP、主机名、厂商（h3c/huawei/cisco/other）、型号、位置
- **认证关联字段**：
  - `auth_type`：认证类型 ENUM('static', 'otp_seed', 'otp_manual')
  - `dept_id`：所属部门 ID（外键，关联 Department 表，顶级部门 = 区域）
  - `device_group`：设备分组 ENUM('core', 'distribution', 'access')
  - `username`：SSH 用户名（仅 static 类型使用，OTP 类型从 DeviceGroupCredential 获取）
  - `password_encrypted`：静态密码加密存储（仅 static 类型）
- 分组信息：重要性等级（与 device_group 关联）
- 生命周期：状态、入库时间、领用人、报废时间
- **凭据获取逻辑**：OTP 类型设备通过 `dept_id` + `device_group` 查询 DeviceGroupCredential 表获取账号和 OTP 种子

**DeviceGroupCredential（设备分组凭据表）** - 新增

- `id`：主键
- `dept_id`：关联部门 ID（外键，指向顶级部门/区域）
- `device_group`：设备分组 ENUM('core', 'distribution', 'access')
- `username`：SSH 账号（每个分组独立账号）
- `otp_seed_encrypted`：该分组的 OTP 种子（AES-256 加密存储）
- `auth_type`：认证类型 ENUM('otp_seed', 'otp_manual')，默认 'otp_seed'
- `description`：凭据描述（如"华北机房A-核心层设备账号"）
- `created_at`：创建时间
- `updated_at`：更新时间
- **复合唯一键**：`(dept_id, device_group)`，确保每个部门的每个设备分组只有一条凭据记录

**说明**：
- 不再需要独立的 Region 表，区域 = 顶级部门，复用现有 Department 表
- 同一部门下，核心、汇聚、接入三个分组各有独立的账号和 OTP 种子
- 同一时间下，不同分组的 OTP 动态验证码各不相同

**Backup（备份表）**

- 关联设备 ID
- 配置内容（TEXT 或 MinIO 路径）
- 备份时间、操作人、备份方式
- MD5 哈希值（用于快速对比）

**Discovery（发现表）**

- IP、MAC、厂商、设备类型
- 首次发现时间、最后活跃时间
- 匹配状态（已匹配/待确认/影子资产）

**DiffRecord（差异记录表）**

- 关联设备 ID 和两次备份 ID
- 差异内容（HTML 格式）
- 告警等级、发送状态

**Template（模板表）**

- 模板名称、模板内容（Jinja2 格式）
- **适用厂商**：支持多选（h3c, huawei, cisco, other）
- 设备类型（交换机/路由器/防火墙）
- 参数定义（参数名、类型、校验规则、默认值）
- 版本号、创建人、审批状态
- 使用次数、最后使用时间

**OtpCache（OTP 缓存）** - Redis 存储

- **存储位置**：Redis（非数据库表）
- **Key 格式**：`otp_cache:{dept_id}:{device_group}`
- **Value 结构**：
  - `otp_value`：用户输入的 OTP 动态验证码
  - `username`：对应账号（从 DeviceGroupCredential 获取）
  - `created_at`：缓存创建时间
- **TTL**：60 秒（自动过期）

**说明**：
- OTP 缓存按 `dept_id` + `device_group` 分组管理
- 同一部门下，核心、汇聚、接入层各有独立的 OTP 缓存
- 用户输入 OTP 后立即并发登录，1 分钟内同分组新设备可复用
- OTP 过期或认证失败时，旧缓存失效，提示用户输入新 OTP

**Task（任务表）** - 新增

- 任务信息：模板、参数、目标设备列表
- 审批信息：提交人、审批人、审批状态
- 执行信息：执行状态、成功/失败设备清单
- 回滚信息：变更前配置备份 ID

### 4.2 索引优化

- Device.ip、Device.hostname 建立索引
- Device.dept_id + Device.device_group 复合索引（用于按部门和设备分组查询凭据）
- Device.dept_id + Device.auth_type 复合索引（用于按部门分组查询）
- DeviceGroupCredential.dept_id + DeviceGroupCredential.device_group 复合唯一索引
- Backup.device_id + backup_time 复合索引
- Discovery.ip、Discovery.mac 建立索引
- Template.vendor（使用 GIN 索引支持数组查询）
- OTP 缓存存 Redis，无需数据库索引（Key: `otp_cache:{dept_id}:{device_group}`）
- 大配置存储使用 MinIO 后仅存元数据

---

## 5. 技术栈集成架构图

### 5.1 整体数据流

```
用户操作（Vue 3）
    ↓
FastAPI 接口层（参数校验、权限控制）
    ↓
Celery 任务队列（Redis Broker）
    ↓
Nornir 批量执行框架
    ├─ Scrapli/Netmiko（SSH 连接）
    ├─ TextFSM（命令输出解析）
    └─ Jinja2（配置生成）
    ↓
设备执行 → 结果聚合 → 存储（PostgreSQL + MinIO）
    ↓
前端展示（实时状态更新 WebSocket）
```

### 5.2 备份任务执行流程

```
1. Celery 定时任务触发
2. 从数据库加载设备清单（IP、凭据、设备类型）
3. Nornir 初始化（设置并发数 num_workers=50）
4. Nornir 调用 ScrapliRunner 连接设备
5. 执行 show running-config 命令
6. 获取原始配置文本
7. 计算 MD5 哈希值（用于快速对比）
8. 存储配置到数据库/MinIO
9. Nornir 聚合结果（成功/失败统计）
10. 更新任务状态到数据库
11. WebSocket 推送完成通知到前端
```

### 5.3 拓扑数据采集流程

```
1. Celery 定时任务触发
2. Nornir 批量执行 show lldp neighbors detail
3. 获取原始文本输出
4. 使用 TextFSM + ntc-templates 解析
   示例：cisco_ios_show_lldp_neighbors_detail.textfsm
5. 解析结果：[{local_port: "Gi1/0/24", neighbor_host: "SW2", neighbor_port: "Gi1/0/1"}]
6. 存储到数据库 Topology 表
7. 前端调用接口获取拓扑数据
8. vis.js 渲染交互式拓扑图
```

### 5.4 配置下发流程

```
1. 用户在前端选择模板（如"创建 VLAN"）
2. 输入参数：vlan_id=100, vlan_name="Finance"
3. 后端参数校验（VLAN 范围 1-4094）
4. Jinja2 渲染模板生成配置预览
   模板示例：
   vlan {{ vlan_id }}
    name {{ vlan_name }}

5. 用户确认后提交审批
6. 审批通过后进入执行阶段
7. Nornir 先连接测试设备执行
8. 验证执行结果（检查错误信息）
9. 测试通过后分批执行（每批 5 台）
10. 每批执行完暂停等待人工确认
11. 全部完成后生成执行报告
```

---

## 6. 安全与权限设计

### 5.1 凭据安全

- 使用 AES-256 对称加密算法加密设备密码
- 加密密钥存储在服务器配置文件（权限 600）或环境变量
- 密钥轮换机制（建议每季度更换一次）
- 凭据使用日志独立记录（哪个用户在什么时间使用了哪台设备的凭据）

### 6.2 RBAC 权限控制

- **只读用户**：仅查看配置、拓扑、定位功能
- **运维人员**：可执行备份、扫描，但批量下发需审批
- **高级管理员**：可审批配置下发，管理凭据
- **超级管理员**：完整权限，可修改审批流程

### 6.3 操作审计

- 所有敏感操作记录到独立审计表（不可删除）
- 记录内容：操作人、时间、IP 地址、操作内容、结果
- 支持按时间范围、操作人、操作类型筛选
- 定期生成审计报告

---

## 7. 性能优化策略

### 7.1 并发控制

- 异步任务并发数限制在 50-100（通过 Nornir num_workers 参数控制）
- 数据库连接池大小根据 Worker 数量调整
- Redis 连接池复用
- Nornir 自动处理任务失败重试和结果聚合

### 7.2 缓存策略

- ARP 表和 MAC 地址表缓存 10 分钟
- 拓扑图数据缓存 30 分钟
- 设备在线状态缓存 5 分钟

### 7.3 存储优化

- 配置文件超过 50KB 自动压缩并存 MinIO
- 定时清理过期备份（保留策略自动执行）
- 扫描结果仅保留最近 90 天
- TextFSM 解析后的结构化数据存 PostgreSQL JSONB 字段（支持 JSON 查询）

---

## 8. 监控与告警

### 8.1 系统监控

- Celery Worker 存活监控（通过 Flower）
- Nornir 任务执行统计（成功率、平均耗时）
- 任务队列堆积告警（超过 100 个待处理任务）
- 数据库连接数告警
- Redis 内存使用告警

### 8.2 业务监控

- 备份任务成功率统计（低于 95% 告警）
- 关键设备连续备份失败告警
- 配置变更频率异常告警（单设备 1 小时内变更超过 3 次）

---

## 9. 潜在风险与应对

### 9.1 厂商兼容性风险

**风险**：不同厂商命令差异大，可能导致功能失效

**应对**：

- 使用 Nornir 插件化架构，支持多种连接库切换
- **优先适配 H3C（85%）**：重点测试 Comware V5/V7，确保核心功能可用
- 建立设备类型自动检测机制（SSH Banner + show/display version）
- 使用 ntc-templates 覆盖主流厂商（H3C、华为、思科模板已有 300+）
- 对于未覆盖厂商，支持自定义 TextFSM 模板扩展
- Jinja2 模板根据厂商类型条件渲染不同命令
- **降级方案**：解析失败时保存原始文本，标记为待人工处理

### 9.2 OTP 认证相关风险

**风险 1**：OTP 过期（30秒）导致批量任务中断

**应对**：

- 用户输入 OTP 后立即并发登录，尽量在 30 秒内完成所有设备认证
- OTP 缓存 1 分钟，给并发登录留出足够窗口
- OTP 过期导致认证失败时，自动暂停任务并提示用户输入新 OTP
- 新 OTP 输入后从失败设备继续执行（断点续传），无需重新开始
- 大批量任务（100+ 设备）分批执行，每批控制在 30 秒内完成登录

**风险 2**：不同部门/设备分组的 OTP 种子管理混乱

**应对**：

- 复用现有 Department 表作为区域管理（顶级部门 = 区域）
- 建立 DeviceGroupCredential 表，按"部门 + 设备分组"管理凭据
- 每个凭据独立加密，互不影响
- 部门或凭据修改/删除时检查关联设备数量，防止误操作

**风险 3**：OTP 种子泄露

**应对**：

- 种子使用独立密钥加密（与静态密码密钥分离）
- 访问种子操作强制记录审计日志
- 定期审查种子访问记录，异常行为告警

### 9.3 性能瓶颈风险

**风险**：1000 台设备全量备份耗时过长

**应对**：

- 分时段备份（核心设备每天，接入层每周）
- 增量备份机制（仅抓取变更配置）
- 根据设备重要性调整备份频率
- 使用 Nornir 并发控制避免网络拥塞
- **OTP 缓存复用**：1 分钟内同分组登录复用 OTP，支持断点续传

### 9.4 安全风险

**风险**：批量下发误操作导致网络中断

**应对**：

- 强制使用 Jinja2 模板（禁止直接输入命令）
- Dry-Run 试运行（渲染后预览配置）
- 灰度发布机制（通过 Nornir 分批执行）
- 强制双人审批（核心设备）
- 自动回滚能力

### 9.5 数据解析失败风险

**风险**：设备输出格式变化或 ntc-templates 未覆盖导致 TextFSM 解析失败

**应对**：

- **优先测试 H3C**：确保主力设备（85%）解析成功率达 95%+
- 解析失败时记录原始输出到 `raw_output` 字段
- 提供降级方案（保存原始文本供人工分析）
- 支持自定义 TextFSM 模板快速修复（管理员上传模板到系统）
- 定期更新 ntc-templates 库到最新版本
- 解析成功率监控（低于 90% 告警）
- 前端标记解析失败的设备，支持一键查看原始输出

---

## 10. 总结

本规划书基于现有 Vue 3 + FastAPI 架构，针对 **H3C 为主（85%）+ 华为（10%）+ 思科（4%）+ OTP 动态认证（98%）** 的实际环境，通过引入 **Celery + Nornir + TextFSM + Jinja2 + PyOTP** 技术栈，实现了安全、高效的网络配置管理系统。

### 核心技术价值

1. **Nornir**：专为网络自动化设计，简化批量设备管理，内置并发控制和失败容错
2. **TextFSM + ntc-templates**：300+ H3C/华为/思科模板，将非结构化命令输出转为结构化数据，无需手写正则
3. **Jinja2**：模板化配置生成，根据设备品牌（H3C/华为/思科）自动适配命令语法，确保配置标准化和安全性
4. **PyOTP + OTP 缓存**：解决 98% 设备 OTP 认证痛点，1 分钟内同分组登录复用 OTP，支持断点续传
5. **Celery**：异步任务调度，解决大规模设备管理性能瓶颈
6. **Scrapli**：原生异步 SSH 库，高并发性能强

### 针对性优化

- **厂商适配优先级**：H3C（85%）> 华为（10%）> 思科（4%），优先保证主力设备可用性
- **OTP 认证架构**：
  - OTP 缓存方案（推荐核心设备）：一次输入 OTP，1 分钟内同分组登录复用，过期自动续期
  - 种子存储方案（推荐普通设备）：PyOTP 自动生成，完全无人值守
  - 混合方案：灵活组合，平衡安全与效率
- **部门 + 设备分组凭据管理**：
  - 复用现有 Department 表（顶级部门 = 区域）
  - DeviceGroupCredential 表按"部门 + 设备分组"管理凭据
  - 每个凭据包含独立的账号 + OTP 种子
  - 同一时间下，同部门的核心、汇聚、接入层 OTP 验证码各不相同
- **解析容错**：TextFSM 失败时保存原始文本，支持人工分析和自定义模板扩展

### 核心亮点

- **多重安全机制**：Jinja2 模板 + 白名单 + 审批流 + 灰度发布 + OTP 双密钥加密
- **智能数据解析**：TextFSM 自动解析 ARP/MAC/LLDP 表为结构化数据（H3C 优先适配）
- **高效并发执行**：Nornir + Scrapli + OTP 缓存实现 1000+ 设备快速备份（支持断点续传）
- **精准定位**：快速解决"PC 在哪个端口"的运维痛点
- **拓扑可视化**：直观展示网络结构，支持多厂商设备
- **生命周期联动**：自动验证资产状态，发现影子资产

按照 Phase 0 → Phase 5 的开发路线逐步推进，既能快速见效（Phase 1 的精准定位 + OTP 缓存机制），又能循序渐进完善功能，降低开发风险。Phase 0 重点搭建 OTP 认证基础设施，为后续所有功能奠定基础。
